<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据库事务与隔离等级 | Sevenhzhang的博客 | Make Progress</title>

  
  <meta name="author" content="Sevenhzhang">
  

  
  <meta name="description" content="九层之台，起于累土">
  

  
  <meta name="keywords" content="Python">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="数据库事务与隔离等级"/>

  <meta property="og:site_name" content="Sevenhzhang的博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Sevenhzhang的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Sevenhzhang的博客</a>
    </h1>
    <p class="site-description">Make Progress</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>数据库事务与隔离等级</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/03/01/数据库事务与隔离等级/" rel="bookmark">
        <time class="entry-date published" datetime="2020-03-01T15:32:00.000Z">
          2020-03-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h4 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1.原子性（Atomicity）"></a>1.原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<a id="more"></a>

<h4 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2.一致性（Consistency）"></a>2.一致性（Consistency）</h4><p>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h4 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3.隔离性（Isolation）"></a>3.隔离性（Isolation）</h4><p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<h4 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4.持久性（Durability）"></a>4.持久性（Durability）</h4><p>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><h4 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1.脏读"></a>1.脏读</h4><p>脏读是指在一个事务处理过程里读取了另一个<strong>未提交</strong>的事务中的数据。</p>
<p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。<br><img src="https://img-blog.csdnimg.cn/20190312094136973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NDI2Ng==,size_16,color_FFFFFF,t_70" alt="脏读"></p>
<h4 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2.不可重复读"></a>2.不可重复读</h4><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务<strong>未提交的脏数据</strong>，而不可重复读则是<strong>读取了前一事务提交的数据</strong>。<br>　　<br><img src="https://img-blog.csdnimg.cn/20190312094424284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NDI2Ng==,size_16,color_FFFFFF,t_70" alt="不可重复读"></p>
<h4 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3.幻读"></a>3.幻读</h4><p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是<strong>不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</strong>。</p>
<p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。<br><img src="https://img-blog.csdnimg.cn/20190312094939797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NDI2Ng==,size_16,color_FFFFFF,t_70" alt="幻读"></p>
<h3 id="MySQL隔离级别"><a href="#MySQL隔离级别" class="headerlink" title="MySQL隔离级别"></a>MySQL隔离级别</h3><h4 id="1-Serializable-串行化-：强制事务串行执行。"><a href="#1-Serializable-串行化-：强制事务串行执行。" class="headerlink" title="1. Serializable (串行化)：强制事务串行执行。"></a>1. Serializable (串行化)：强制事务串行执行。</h4><p>  可避免脏读、不可重复读、幻读的发生。</p>
<h4 id="2-Repeatable-read-可重复读-：保证在同一个事务中多次读取同样数据的结果是一样的"><a href="#2-Repeatable-read-可重复读-：保证在同一个事务中多次读取同样数据的结果是一样的" class="headerlink" title="2. Repeatable read (可重复读)：保证在同一个事务中多次读取同样数据的结果是一样的"></a>2. Repeatable read (可重复读)：保证在同一个事务中多次读取同样数据的结果是一样的</h4><p>可避免脏读、不可重复读的发生。</p>
<h4 id="3-Read-committed-读已提交-：一个事务只能读取已经提交的事务所做的修改"><a href="#3-Read-committed-读已提交-：一个事务只能读取已经提交的事务所做的修改" class="headerlink" title="3. Read committed (读已提交)：一个事务只能读取已经提交的事务所做的修改"></a>3. Read committed (读已提交)：一个事务只能读取已经提交的事务所做的修改</h4><p>可避免脏读的发生。</p>
<h4 id="4-Read-uncommitted-读未提交-：事务中的修改，即使没有提交，对其他事务也是可见的"><a href="#4-Read-uncommitted-读未提交-：事务中的修改，即使没有提交，对其他事务也是可见的" class="headerlink" title="4. Read uncommitted (读未提交)：事务中的修改，即使没有提交，对其他事务也是可见的"></a>4. Read uncommitted (读未提交)：事务中的修改，即使没有提交，对其他事务也是可见的</h4><p>最低级别，任何情况都无法保证。</p>
<p> 隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，级别越高，执行效率就越低。</p>
<p>像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。</p>
<p>在<strong>MySQL</strong>数据库中默认的隔离级别为<strong>Repeatable read (可重复读)</strong>。</p>
<p><strong>Oracle</strong>数据库中，只支持 <strong>Serializable (串行化)</strong> 级别和 <strong>Read committed (读已提交)</strong> 这两种级别，其中默认的为Read committed级别。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/数据库/">数据库</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/事务/">事务</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 Sevenhzhang
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>